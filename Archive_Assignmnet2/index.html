<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quick Draw Garden Grid</title>
    <!-- Load Tailwind CSS from CDN for easy, modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles to match the minimalist, centered aesthetic and color palette from the image */
        body {
            font-family: 'Inter', sans-serif;
            /* UPDATED: Background color to match the softer, warmer palette from the new image */
            background-color: #E6E0DD; 
            /* UPDATED: Deep indigo color replaced with a soft, warm gray for text, dots, and drawings */
            color: #686460; 
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            /* Ensure the body takes up exactly the viewport height and prevents vertical scrolling issues */
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            /* Set box-sizing to border-box globally to prevent padding/border from causing overflow */
            box-sizing: border-box; 
        }
        
        .container-main {
            /* Now uses max-width to control the container size, and is centered */
            width: 100%;
            max-width: 600px; /* Limit main content width */
            padding: 0 1rem; /* Reduced horizontal padding to prevent overflow on very small screens */
            text-align: center;
            box-sizing: border-box;
        }

        /* --- Tab Styling --- */
        .tab-button {
            padding: 8px 16px;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: border-bottom-color 0.2s, opacity 0.2s;
            opacity: 0.7;
        }

        .tab-button:hover {
            opacity: 1;
        }

        .tab-active {
            font-weight: bold;
            /* UPDATED: Tab active color to new primary accent color */
            border-bottom-color: #686460;
            opacity: 1;
        }
        /* --- End Tab Styling --- */

        .dot-svg {
            /* Styling for the initial dot state */
            stroke: currentColor; /* Inherits #686460 from body */
            stroke-width: 0; /* Hide stroke for filled squares */
            transition: transform 0.1s ease-out;
            cursor: pointer;
        }
        
        .dot-svg rect {
             /* UPDATED: Use a filled, slightly lighter color for the dots */
             fill: #C3B9B0; 
             transition: fill 0.3s;
        }

        /* FIX: Add a hover effect to confirm visibility and interactivity */
        .dot-svg rect:hover {
            fill: #C0A89A; /* Slightly darker shade for visual feedback */
        }

        .flower-svg {
            /* Container styling (no fill) */
            fill: none; 
            transition: all 0.5s ease-in-out;
            cursor: default; /* Change cursor for planted items */
            /* CRITICAL FIX: Allow the content to overflow the SVG's viewbox without being clipped */
            overflow: visible;
        }
        
        /* Styles for the animation: applies to all paths inside a flower SVG */
        .flower-svg path {
            /* Stroke color inherited from body (#686460) */
            stroke: currentColor; 
            stroke-width: 4; /* Increased stroke weight */
            stroke-linecap: round;
            stroke-linejoin: round;
            /* Increased transition duration to 1.0s for slower drawing speed */
            transition: stroke-dashoffset 1.0s ease-out; 
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    // Custom colors are simplified since we now rely on 'currentColor' from the body
                    colors: {
                        'plant-color': '#686460',
                    }
                }
            }
        }
    </script>
</head>
<body>
    
    <!-- Simplified container to match the clean background -->
    <div class="container-main">
        <header class="text-center mb-8 mt-4"> <!-- Increased margin bottom and added margin top for spacing -->
            <!-- Tab Selector -->
            <div id="category-selector" class="flex justify-center mb-8 border-b border-gray-300">
                <button 
                    id="tab-flora" 
                    class="tab-button tab-active mr-4"
                    onclick="changeGroup('flora')"
                >
                    Flora
                </button>
                <button 
                    id="tab-fauna" 
                    class="tab-button ml-4"
                    onclick="changeGroup('fauna')"
                >
                    Fauna
                </button>
            </div>

            <!-- Replaced text heading with image -->
            <img 
                src="title_logo.svg" 
                alt="Doodle Forest Title Logo" 
                class="mx-auto h-20 max-h-20 w-auto object-contain mb-2"
                onerror="this.onerror=null; this.src='https://placehold.co/300x80/686460/E6E0DD?text=Doodle+Forest'"
            >
            
            <!-- The subtitle for active group status remains commented out -->
        </header>

        <!-- The 10x10 Grid Container, with reduced gap for a denser look -->
        <div id="garden-grid" class="grid grid-cols-10 gap-1 md:gap-1 aspect-square w-full">
            <!-- Dots will be populated here by JavaScript -->
        </div>

        <!-- Status Bar Wrapper for Centering and Preventing Layout Shift -->
        <div class="mt-4 flex justify-center">
            <div id="status-bar" 
                 class="text-center text-base font-semibold py-2 px-4 rounded-lg 
                        transition-opacity duration-300 opacity-0" 
                 style="color: #686460; background-color: #D6D0CC; min-width: 150px;"> 
                <!-- min-width ensures it doesn't collapse to 0px when empty/faded -->
            </div>
        </div>
        <!-- END Status Bar Wrapper -->

    </div>


<script>
    // =========================================================================
    // STEP 1: CONFIGURATION & STATE
    // =========================================================================
    
    // Base directory where your Quick Draw data files are now located.
    const BASE_PATH = './quick_draw_local/';

    // File paths are updated to match the casing and naming conventions seen in your local file list screenshot.
    const FILE_PATHS = {
        // Flora Files
        flower: BASE_PATH + 'flower_data_local.ndjson', 
        tree: BASE_PATH + 'tree_data_local.ndjson', 
        grass: BASE_PATH + 'Grass_data_local.ndjson', 

        // Fauna Files (based on files in your folder)
        bear: BASE_PATH + 'Bear_data_local.ndjson',
        lion: BASE_PATH + 'Lion_data_local.ndjson',
        // FIX: Replaced 'Bird Data_data_local.ndjson' with the correct URL encoded path to handle the space
        bird: BASE_PATH + 'Bird%20Data_data_local.ndjson',
        monkey: BASE_PATH + 'Monkey_data_local.ndjson',
        crocodile: BASE_PATH + 'Crocodile_data_local.ndjson',
        giraffe: BASE_PATH + 'Giraffe_data_local.ndjson',
        zebra: BASE_PATH + 'Zebra_data_local.ndjson',
        snake: BASE_PATH + 'Snake_data_local.ndjson',
        tiger: BASE_PATH + 'Tiger_data_local.ndjson',
    };
    
    // Group definitions for randomization
    const FLORA_CATEGORIES = ['flower', 'tree', 'grass'];
    const FAUNA_CATEGATEGORIES = ['bear', 'lion', 'bird', 'monkey', 'crocodile', 'giraffe', 'zebra', 'snake', 'tiger'];
    const ALL_CATEGORIES = [...FLORA_CATEGORIES, ...FAUNA_CATEGATEGORIES];

    // Store all loaded drawings, keyed by category
    const DRAWING_DATA = {};
    ALL_CATEGORIES.forEach(cat => DRAWING_DATA[cat] = []); 

    // State to track which drawing indices have been used for each category
    const USED_DRAWINGS = {};
    ALL_CATEGORIES.forEach(cat => USED_DRAWINGS[cat] = new Set());

    let activeGroup = 'flora'; // Initial selected group: 'flora' or 'fauna'
    let isDragging = false; // State for drag-and-plant functionality

    const GRID_SIZE = 10;
    const GRID_CONTAINER_ID = 'garden-grid';
    // Update: Decreased DOT_SIZE from 40 to 30 for a slightly smaller look
    const DOT_SIZE = 30; 
    const DOT_ROUNDING = 8; // Corner radius for the square
    
    // Global reference for the status bar element
    let statusBar = null; 

    // =========================================================================
    // STEP 2: UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Converts the compressed Quick Draw stroke data (vectors) into an SVG path string.
     */
    function drawingToSvgPath(drawing) {
        let svgContent = '';
        const scaleFactor = 100 / 256; // Quick Draw data is scaled from 256x256 to our 100x100 viewBox

        drawing.forEach(stroke => {
            // stroke is an array of [x_coords, y_coords, [time_steps]]
            const xCoords = stroke[0];
            const yCoords = stroke[1];

            let pathData = '';
            for (let i = 0; i < xCoords.length; i++) {
                const x = xCoords[i] * scaleFactor;
                const y = yCoords[i] * scaleFactor;

                if (i === 0) {
                    // Move to the start of the stroke
                    pathData += `M${x},${y}`;
                } else {
                    // Line to the next point
                    pathData += `L${x},${y}`;
                }
            }
            // Use a class "flower-stroke" to select paths for animation
            svgContent += `<path class="flower-stroke" d="${pathData}"/>`;
        });

        // Wrap paths in a group element for easier styling
        return `<g class="flower-container">${svgContent}</g>`;
    }

    /**
     * Parses the NDJSON string and populates the DRAWING_DATA array for the given category.
     */
    function processData(ndjsonData, category) {
        if (!ndjsonData || !ndjsonData.trim()) {
            console.error(`NDJSON data for ${category} is empty or invalid after loading.`);
            return;
        }

        const lines = ndjsonData.trim().split('\n');
        
        const drawings = lines.map(line => {
            try {
                const data = JSON.parse(line);
                return data.drawing; 
            } catch (e) {
                return null;
            }
        }).filter(drawing => drawing !== null);

        DRAWING_DATA[category] = drawings;

        if (drawings.length === 0) {
            console.warn(`No valid ${category} drawings found in the dataset.`);
        }
        console.log(`Loaded ${drawings.length} valid ${category} drawings.`);
    }

    /**
     * Loads the Quick Draw data asynchronously for a specific category.
     */
    async function loadData(category) {
        const filePath = FILE_PATHS[category];
        console.log(`Attempting to load data for ${category} from ${filePath}...`);
        
        try {
            // Implement simple exponential backoff for robust file loading
            const maxRetries = 3;
            let response = null;
            
            for (let i = 0; i < maxRetries; i++) {
                try {
                    response = await fetch(filePath);
                    if (response.ok) {
                        break; // Success!
                    }
                } catch (e) {
                    // Network error, try again after a delay
                }

                if (i < maxRetries - 1) {
                    const delay = Math.pow(2, i) * 1000; // 1s, 2s, 4s delay
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }

            if (!response || !response.ok) {
                // If the loop finished without a successful response
                let errorDetails = response ? `Status: ${response.status}` : 'No response received.';
                
                // ADDED: Detailed logging for file not found
                if (response && response.status === 404) {
                    console.error(`ERROR: File not found (404) for '${category}'. Please ensure the filename (case/spaces/extension) is EXACTLY correct and the path: ${filePath} is valid.`);
                } else {
                    console.error(`ERROR: Failed to fetch data for ${category}. Details: ${errorDetails}`);
                }
                return; // Stop processing this category
            }

            const textData = await response.text();
            processData(textData, category);
            
        } catch (error) {
            console.error(`Failed to load Quick Draw data for ${category}:`, error);
        }
    }

    /**
     * Updates the UI to reflect the currently selected drawing group.
     */
    function updateCategoryDisplay() {
        // Update tab styling
        document.getElementById('tab-flora').classList.remove('tab-active');
        document.getElementById('tab-fauna').classList.remove('tab-active');
        document.getElementById(`tab-${activeGroup}`).classList.add('tab-active');
        
        // Subtitle is commented out as requested
    }

    /**
     * Changes the currently active drawing group (Flora or Fauna).
     */
    window.changeGroup = function(newGroup) {
        activeGroup = newGroup;
        updateCategoryDisplay();
        console.log(`Active planting group changed to: ${activeGroup}`);
    }

    /**
     * Sets up mouseover/mouseout listeners on a planted SVG to display its category name
     * in the dedicated status bar and show the bar only on hover.
     */
    function setupPlantedHover(svgElement, categoryName) {
        
        // Function to run on mouse enter
        function handleMouseEnter() {
            if (statusBar) {
                // 1. Display the name of the planted item
                statusBar.textContent = ` ${categoryName}`;
                // 2. Show the container by setting opacity to 100 (smooth transition handled by CSS)
                statusBar.classList.remove('opacity-0');
                statusBar.classList.add('opacity-100');
            }
        }
        
        // Function to run on mouse leave
        function handleMouseLeave() {
            if (statusBar) {
                // 1. Hide the container by setting opacity to 0
                statusBar.classList.remove('opacity-100');
                statusBar.classList.add('opacity-0');
            }
        }

        svgElement.addEventListener('mouseenter', handleMouseEnter);
        svgElement.addEventListener('mouseleave', handleMouseLeave);
    }


    /**
     * Handles mouseover or mousedown event on a dot, triggering planting 
     * if the mouse button is currently held down (isDragging is true).
     */
    function handleDotInteraction(event) {
        // Only plant if the mouse button is currently held down (dragging)
        // OR if this is a direct mousedown event starting the drag
        if (!isDragging && event.type !== 'mousedown') {
            return;
        }

        const svgElement = event.currentTarget;
        
        if (svgElement.dataset.planted) {
            return;
        }
        
        // 1. Determine which set of categories to use
        const categoriesInGroup = activeGroup === 'flora' ? FLORA_CATEGORIES : FAUNA_CATEGATEGORIES;
        
        // 2. Filter out categories that failed to load (or have no drawings)
        const loadedCategories = categoriesInGroup.filter(cat => DRAWING_DATA[cat] && DRAWING_DATA[cat].length > 0);

        if (loadedCategories.length === 0) {
            // Check if loading is still in progress (highly unlikely if grid is active, but safe check)
            if (Object.values(DRAWING_DATA).every(arr => arr.length === 0)) {
                console.error("No drawings loaded yet. Waiting for data to load or check file paths.");
            } else {
                console.warn(`No drawings loaded for the active group: ${activeGroup}. Please check your files or the category filter.`);
            }
            return;
        }

        // 3. Select a random loaded category within the active group
        const randomCategoryIndex = Math.floor(Math.random() * loadedCategories.length);
        const selectedCategory = loadedCategories[randomCategoryIndex];
        
        // 4. Get drawings and used indices for the selected category
        const availableDrawings = DRAWING_DATA[selectedCategory];
        const usedIndices = USED_DRAWINGS[selectedCategory];

        // 5. Check for available unique drawings
        const totalDrawings = availableDrawings.length;
        if (usedIndices.size >= totalDrawings) {
            console.warn(`All unique drawings for category '${selectedCategory}' have been used. Cannot plant a unique item.`);
            return;
        }
        
        // 6. Find a random *unused* index
        let randomIndex;
        do {
            randomIndex = Math.floor(Math.random() * totalDrawings);
        } while (usedIndices.has(randomIndex));

        // 7. Mark this index as used
        usedIndices.add(randomIndex);

        // 8. Select the drawing and proceed
        const rawDrawing = availableDrawings[randomIndex];
        
        // 9. Convert raw drawing data to SVG path content and replace the dot
        const flowerSvgContent = drawingToSvgPath(rawDrawing);
        
        while (svgElement.firstChild) {
            svgElement.removeChild(svgElement.firstChild);
        }
        svgElement.innerHTML = flowerSvgContent;
        svgElement.dataset.planted = 'true';

        // NEW: Store the category and set up the custom hover status bar
        svgElement.dataset.category = selectedCategory; 
        const readableCategoryName = selectedCategory.charAt(0).toUpperCase() + selectedCategory.slice(1);
        
        // Setup the hover listeners to update the status bar
        setupPlantedHover(svgElement, readableCategoryName); 
        
        // Cleanup classes
        svgElement.classList.remove('dot-svg', 'cursor-pointer');
        svgElement.classList.add('flower-svg');
        
        // Remove mouse interaction listeners now that the cell is planted
        svgElement.removeEventListener('mouseover', handleDotInteraction);
        svgElement.removeEventListener('mousedown', handleDotInteraction);


        // 10. ANIMATION LOGIC: Draw the strokes sequentially
        const paths = svgElement.querySelectorAll('.flower-stroke');
        let delay = 0;
        const delayIncrement = 300; // Delay between strokes

        paths.forEach(path => {
            if (typeof path.getTotalLength === 'function') {
                const length = path.getTotalLength();
                path.style.strokeDasharray = length + ' ' + length;
                path.style.strokeDashoffset = length;

                setTimeout(() => {
                    path.style.strokeDashoffset = '0';
                }, delay);
                
                delay += delayIncrement;
            } else {
                console.warn("Path element does not support getTotalLength for animation.");
            }
        });
    }

    // =========================================================================
    // STEP 3: INITIALIZATION
    // =========================================================================

    /**
     * Initializes the 10x10 grid with clickable dots, then loads the data.
     */
    async function initializeGrid() {
        const gridContainer = document.getElementById(GRID_CONTAINER_ID);
        gridContainer.innerHTML = ''; 

        // Set global reference to status bar
        statusBar = document.getElementById('status-bar');

        // A. Initial setup of the empty grid
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            const cell = document.createElement('div');
            // FIX: Added 'overflow-visible' to the cell to ensure it doesn't clip children
            cell.className = 'w-full h-full flex items-center justify-center overflow-visible';

            const dotSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            dotSvg.setAttribute('viewBox', '0 0 100 100');
            dotSvg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            dotSvg.classList.add('w-full', 'h-full', 'dot-svg', 'cursor-pointer');

            // UPDATED: Use a rectangle for a rounded square dot
            const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            // Calculate position for centering the square in the 100x100 view box
            const offset = (100 - DOT_SIZE) / 2; 
            rect.setAttribute('x', offset);
            rect.setAttribute('y', offset);
            rect.setAttribute('width', DOT_SIZE);
            rect.setAttribute('height', DOT_SIZE);
            rect.setAttribute('rx', DOT_ROUNDING); // Corner radius
            rect.setAttribute('ry', DOT_ROUNDING);
            dotSvg.appendChild(rect);

            // Add drag interaction listeners
            dotSvg.addEventListener('mouseover', handleDotInteraction);
            dotSvg.addEventListener('mousedown', handleDotInteraction); 

            cell.appendChild(dotSvg);
            gridContainer.appendChild(cell);
        }
        
        // B. Add global event listeners for drag functionality on the grid container
        gridContainer.addEventListener('mousedown', (e) => {
            // Check if primary button (left click) is pressed
            if (e.button === 0) { 
                isDragging = true;
            }
        });

        // Set isDragging to false when mouse button is released anywhere on the document
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // C. Update initial display
        updateCategoryDisplay();

        // D. Load and process data asynchronously for all categories
        await Promise.all(
            ALL_CATEGORIES.map(category => loadData(category))
        );
        
        console.log("All data loading attempts complete.");
    }

    // Initialize the grid when the page loads
    window.onload = initializeGrid;
</script>

</body>
</html>
